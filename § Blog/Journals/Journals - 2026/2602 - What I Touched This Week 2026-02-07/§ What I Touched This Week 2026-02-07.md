---
date: 2026-02-07
description: My weekly review report.
series:
  - What I Touched
tags:
  - ai-generated
obsidianFiles:
  - robot/Readwise Library/Readwise Syncs/Readwise Sync 2026-02-07
  - robot/Readwise Library/Articles/Brent Yorgey - Typeclassopedia (Highlights)
  - robot/Readwise Library/Articles/Miran Lipovača - Learn You a Haskell for Great Good Chapter 9. Input and Output (Highlights)
  - robot/Readwise Library/Articles/Bryan O'Sullivan et al. - Real World Haskell Chapter 7. IO (Highlights)
  - robot/Readwise Library/Articles/Haddock Authors - Documentation and Markup (Highlights)
  - robot/Readwise Library/Articles/Sean Goedecke - How I estimate work (Highlights)
  - para/lets/d/Development Environment/JavaScript Shell Scripting
---
# What I Touched This Week 2026-02-07

**Status**:: #x
**Zettel**:: #zettel/permanent
**Created**:: [[2025-11-29]]
**URL**:: [blog.iany.me](https://blog.iany.me/journal/2026/02/what-i-touched-this-week-2026-02-07/)
**Highlights**:: [[Readwise Sync 2026-02-07]]

> [!attention] This journal is generated by AI

<!--more-->
## Haskell: Typeclassopedia, IO, and Documentation

This week was heavily Haskell-focused. I worked through the [Typeclassopedia](https://wiki.haskell.org/Typeclassopedia), [Learn You a Haskell Chapter 9 (Input and Output)](https://learnyouahaskell.github.io/input-and-output.html), and [Real World Haskell Chapter 7 (IO)](https://book.realworldhaskell.org/read/io.html), plus the [Haddock markup guide](https://haskell-haddock.readthedocs.io/latest/markup.html).

- **Monad vs Applicative**: The structure of an Applicative computation is fixed; a Monad’s structure can depend on intermediate results. That’s why `(>>=)` (bind) is strictly more powerful than `(<*>)`. Prefer Applicative when you don’t need that—it can allow parallelization where monadic code cannot.
- **Reader, Writer, State**: The `(->) e` reader monad gives a read-only environment; `Writer` accumulates a monoidal log; `State s a` is `s -> (a,s)` for stateful computations. All live in `Control.Monad` and the mtl library.
- **IO in practice**: `getContents` does lazy I/O; `interact` captures the pattern of “read, transform, output.” Use `withFile` for handle-based file I/O. Prefer `Maybe`/`Either` in pure code and reserve exceptions for the IO part; catch with `System.IO.Error.catch` and predicates like `isDoesNotExistError`.
- **Haddock**: Use `-- |` before or `-- ^` after declarations; document arguments inline. Headings with `-- *`, `-- **`; link identifiers with single quotes/backticks and modules with double quotes; code blocks with `@...@` or bird tracks `>`.

## Use Bun for Shell Scripts

I published a post on [[§ Use Bun for Shell Scripts|using Bun for cross-platform shell scripts]] on Windows. Bun avoids shebang and WSL/Git-bash setup while giving a single runtime for ad-hoc commands and full scripts.

- **Single binary**: `bun build ./script.ts --compile --outfile script` produces a native executable, so no shebang or interpreter is needed on Windows.
- **Bun Shell**: `Bun.$` builds shell commands from template literals (similar to zx). On Windows, Bun ships with MSYS for a consistent bash environment.
- **Extras**: `Bun.secrets` for the OS keystore, built-in globs, YAML, ANSI. Fast startup (~5ms vs Node’s ~25ms for simple scripts) helps for small, frequent scripts.

Sources:
- [[§ Use Bun for Shell Scripts]]
- [[JavaScript Shell Scripting]]

## How I Estimate Work

[Sean Goedecke’s post](https://www.seangoedecke.com/how-i-estimate-work/) reframes estimation as a political and constraint-satisfaction problem rather than a pure “how long will this take?” question.

- **Context first**: Gather political context before looking at code—pressure on the project, what kind of estimate the chain wants, whether this is a casual ask or a must-have.
- **Inversion**: The job isn’t “break down work to get a duration.” It’s “find the set of software approaches that fit the timeline they already have in mind.”
- **If you don’t estimate**: Someone less technical will estimate for you. Engaging with the process lets you steer which approaches are in scope.

---

## Obsidian Links
- [[Readwise Sync 2026-02-07]]
- [[Brent Yorgey - Typeclassopedia (Highlights)]]
- [[Miran Lipovača - Learn You a Haskell for Great Good Chapter 9. Input and Output (Highlights)]]
- [[Bryan O'Sullivan et al. - Real World Haskell Chapter 7. IO (Highlights)]]
- [[Haddock Authors - Documentation and Markup (Highlights)]]
- [[Sean Goedecke - How I estimate work (Highlights)]]
- [[JavaScript Shell Scripting]]

---
date: 2026-02-01
description: My weekly review report.
series:
- What I Touched
tags:
- ai-generated
obsidianFiles:
- para/lets/p/Programming/Haskell Applicative
- para/lets/p/Programming/Haskell Pattern Matching
- para/lets/p/Programming/Haskell High-Order Function Composition
- robot/Readwise Library/Articles/Miran Lipovača - Learn You a Haskell for Great Good Chapter 11. Functors, Applicative Functors and Monoids (Highlights)
- robot/Readwise Library/Articles/Miran Lipovača - Learn You a Haskell for Great Good Chapter 6. Higher Order Functions (Highlights)
- robot/Readwise Library/Articles/Haskell Authors - Foldl (Highlights)
- robot/Readwise Library/Tweets/Sandeep Palakodeti - The Tippy Top (Highlights)
- output/§ Blog/Posts/Posts - 2026/2601 - Use tmux for PowerShell in Windows Terminal/§ Use tmux for PowerShell in Windows Terminal
---
# What I Touched This Week 2026-02-01

**Status**:: #x
**Zettel**:: #zettel/permanent
**Created**:: [[2026-02-01]]
**URL**:: [blog.iany.me](https://blog.iany.me/journal/2026/02/what-i-touched-this-week-2026-02-01/)
**Highlights**:: [[Readwise Sync 2026-02-01]]

> [!attention] This journal is generated by AI

<!--more-->

## Haskell Type Classes: Functors, Applicatives, and Monoids

This week I dove deep into Haskell's type class hierarchy, working through Learn You a Haskell and the CIS 194 course materials. The key insight is understanding how these abstractions compose to enable powerful, generic programming.- **Functors** are types that can be mapped over. The `fmap` function can be viewed as "lifting" a function: `fmap :: (a -> b) -> (f a -> f b)` transforms an ordinary function into one that works inside a functor context
- The **functor laws** ensure predictable behavior: `fmap id = id` (identity preservation) and `fmap (f . g) = fmap f . fmap g` (composition preservation)
- **Applicatives** extend functors by allowing wrapped functions to be applied to wrapped values using `<*>`. Lists as applicatives represent non-deterministic computations where `[(+3),(*2)] <*> [1,2]` produces all combinations
- **ZipList** provides an alternative applicative instance for lists using pairwise application instead of all combinations
- **Monoids** provide an identity element (`mempty`) and an associative binary operation (`mappend`). The `foldMap` function reveals why monoids matter: the identity handles empty structures and the associative operation combines values reliably
- Use `foldl'` from `Data.List` instead of `foldl` to avoid building huge thunks; `foldr` is better when the folding function can short-circuit

Sources:
- [Learn You a Haskell: Functors, Applicative Functors and Monoids](https://learnyouahaskell.github.io/functors-applicative-functors-and-monoids.html)
- [CIS 194: Higher-order programming and type inference](https://www.seas.upenn.edu/~cis1940/spring13/lectures/04-higher-order.html)
- [Haskell Wiki: Foldr Foldl Foldl'](https://wiki.haskell.org/Foldr_Foldl_Foldl')

## Using tmux for PowerShell in Windows Terminal

I published a blog post on getting tmux session persistence in Windows Terminal while keeping PowerShell as the default shell. The solution runs tmux through WSL but configures it to spawn `pwsh.exe` for new panes.

- Create thin wrapper scripts (`tmux.ps1`, `tmux.cmd`) so `tmux` from Windows means `wsl tmux`
- A helper script `tmux-pwsh.ps1` creates or attaches to named sessions with `pwsh.exe -nologo` as the default command
- The key trick: send `set-option default-command` via `tmux -C attach` because running `wsl tmux set-option` immediately after session creation has a race condition where the session isn't ready
- After setup, splitting panes and creating windows in that session will all start PowerShell in the Windows environment

## Elite Performance Through Preparation

An insightful [thread by Sandeep Palakodeti](https://x.com/DrDeepMD/status/2015810417839227390/) on what separates elite performers from amateurs. The core message: greatness is not about taking risks but eliminating variance through preparation.

- When experts operate at their limit, they're not "trying hard"—they're executing scripts that have been debugged for decades through deliberate, high-fidelity repetition
- Fear is the biological response to the unknown; when you've accounted for every variable, fear is replaced by focus
- Elite performers aim *below* the edge of their ability because that's where consistency lives
- Every question gets answered upstream, every branch point gets a playbook—by the time the moment arrives, they're executing state changes, not solving problems
- "Don't worship the risk. Worship the work that made the risk irrelevant."

---

## Obsidian Links
- [[Haskell Applicative]]
- [[Haskell Pattern Matching]]
- [[Haskell High-Order Function Composition]]
- [[Miran Lipovača - Learn You a Haskell for Great Good Chapter 11. Functors, Applicative Functors and Monoids (Highlights)]]
- [[Miran Lipovača - Learn You a Haskell for Great Good Chapter 6. Higher Order Functions (Highlights)]]
- [[Haskell Authors - Foldl (Highlights)]]
- [[Sandeep Palakodeti - The Tippy Top (Highlights)]]
- [[§ Use tmux for PowerShell in Windows Terminal]]

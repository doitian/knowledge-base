---
date: 2026-01-17
description: My weekly review report.
series:
  - What I Touched
tags:
  - ai-generated
obsidianFiles:
  - robot/Readwise Library/Articles/Lewis Daly - One for the Treble, Two for the Time (Highlights)
  - robot/Readwise Library/Articles/Martin Fowler - Temporal Patterns (Highlights)
  - robot/Readwise Library/Articles/Tony Bai - 从入门到极致：VictoriaMetrics 教你写出最高效的 Go 代码 (Highlights)
  - robot/Readwise Library/Articles/Jochen Christ - Which Version of JDK Should I Use (Highlights)
---
# What I Touched This Week 2026-01-17

**Status**:: #x
**Zettel**:: #zettel/permanent
**Created**:: [[2026-01-17]]
**URL**:: [blog.iany.me](https://blog.iany.me/journal/2026/01/what-i-touched-this-week-2026-01-17/)
**Highlights**:: [[Readwise Sync 2026-01-17]]

> [!attention] This journal is generated by AI

<!--more-->

## Temporal Patterns and Bitemporality

This week I explored the concept of bitemporality and temporal patterns in data modeling. The key insight is that we need to track two dimensions of time: **actual time** (when something happened) and **record time** (when we learned about it). This becomes crucial when we need to answer questions like "what did we think the state was two months ago?" or "what did we know six months ago about something that happened earlier?"

Sources:
- [One for the Treble, Two for the Time](https://tigerbeetle.com/blog/2026-01-14-bitemporality/) by Lewis Daly
- [Temporal Patterns](https://martinfowler.com/eaaDev/timeNarrative.html) by Martin Fowler

## Go Performance Optimization Techniques

I learned several advanced Go performance optimization techniques from VictoriaMetrics, a high-performance time-series database. The key strategies include using `sync.Pool` for object reuse to reduce GC pressure, implementing channel-based object pools for more controlled resource management, and using sharding to reduce lock contention by splitting large data structures into independent shards.

- Use `sync.Pool` for object reuse to minimize garbage collection overhead
- Channel-based object pools provide more control than `sync.Pool`
- Sharding large data structures reduces lock contention
- Localized worker pools with independent channels improve multi-core scalability
- Buffered channels can serve as semaphores for rate limiting

Source: [从入门到极致：VictoriaMetrics 教你写出最高效的 Go 代码](https://mp.weixin.qq.com/s/1svEokrz5C0FwBEA88YGqw) by Tony Bai

## JDK Selection Guidelines

I reviewed best practices for choosing a Java Development Kit (JDK) version and distribution. The primary recommendation is to use **Adoptium Eclipse Temurin 21**.

Source: [Which Version of JDK Should I Use](https://whichjdk.com/) by Jochen Christ

---

## Obsidian Links
- [[Lewis Daly - One for the Treble, Two for the Time (Highlights)]]
- [[Martin Fowler - Temporal Patterns (Highlights)]]
- [[Tony Bai - 从入门到极致：VictoriaMetrics 教你写出最高效的 Go 代码 (Highlights)]]
- [[Jochen Christ - Which Version of JDK Should I Use (Highlights)]]
